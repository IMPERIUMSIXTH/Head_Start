"""
Vulnerability analysis and processing engine.

This module provides advanced vulnerability analysis capabilities including:
- Vulnerability prioritization and risk assessment
- Remediation plan generation
- Trend analysis and reporting
- False positive detection and filtering
"""

import logging
from collections import defaultdict
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Dict, List, Optional, Set, Tuple

from .security_scanner import (
    SecurityScanResults, 
    SeverityLevel, 
    Vulnerability, 
    VulnerabilityType
)

logger = logging.getLogger(__name__)


class RiskLevel(str, Enum):
    """Risk levels for vulnerability assessment."""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    NEGLIGIBLE = "NEGLIGIBLE"


class RemediationPriority(str, Enum):
    """Priority levels for remediation."""
    IMMEDIATE = "IMMEDIATE"
    URGENT = "URGENT"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"


@dataclass
class VulnerabilityRiskAssessment:
    """Risk assessment for a vulnerability."""
    vulnerability_id: str
    risk_level: RiskLevel
    exploitability_score: float  # 0.0 to 10.0
    impact_score: float  # 0.0 to 10.0
    likelihood_score: float  # 0.0 to 10.0
    business_impact: str
    technical_impact: str
    remediation_priority: RemediationPriority
    estimated_remediation_hours: Optional[int] = None


@dataclass
class RemediationAction:
    """Represents a remediation action for vulnerabilities."""
    action_id: str
    title: str
    description: str
    priority: RemediationPriority
    estimated_hours: int
    affected_vulnerabilities: List[str]
    prerequisites: List[str] = field(default_factory=list)
    verification_steps: List[str] = field(default_factory=list)
    resources_needed: List[str] = field(default_factory=list)


@dataclass
class RemediationPlan:
    """Comprehensive remediation plan."""
    plan_id: str
    created_at: datetime
    total_vulnerabilities: int
    critical_count: int
    high_count: int
    estimated_total_hours: int
    actions: List[RemediationAction]
    timeline_weeks: int
    success_criteria: List[str]
    
    def get_immediate_actions(self) -> List[RemediationAction]:
        """Get actions that need immediate attention."""
        return [
            action for action in self.actions 
            if action.priority == RemediationPriority.IMMEDIATE
        ]
    
    def get_actions_by_priority(self, priority: RemediationPriority) -> List[RemediationAction]:
        """Get actions by priority level."""
        return [
            action for action in self.actions 
            if action.priority == priority
        ]


@dataclass
class VulnerabilityTrend:
    """Represents vulnerability trends over time."""
    period: str
    vulnerability_counts: Dict[SeverityLevel, int]
    new_vulnerabilities: int
    resolved_vulnerabilities: int
    trend_direction: str  # "improving", "stable", "degrading"
    risk_score_change: float


@dataclass
class AnalysisReport:
    """Comprehensive vulnerability analysis report."""
    report_id: str
    scan_results: SecurityScanResults
    risk_assessments: List[VulnerabilityRiskAssessment]
    remediation_plan: RemediationPlan
    trends: Optional[List[VulnerabilityTrend]] = None
    executive_summary: str = ""
    recommendations: List[str] = field(default_factory=list)


class VulnerabilityAnalyzer:
    """Advanced vulnerability analysis and processing engine."""
    
    def __init__(self):
        """Initialize the vulnerability analyzer."""
        self.false_positive_patterns = self._load_false_positive_patterns()
        self.remediation_templates = self._load_remediation_templates()
    
    def analyze_vulnerabilities(
        self, 
        scan_results: SecurityScanResults,
        historical_data: Optional[List[SecurityScanResults]] = None
    ) -> AnalysisReport:
        """Perform comprehensive vulnerability analysis."""
        logger.info(f"Analyzing vulnerabilities for scan: {scan_results.scan_id}")
        
        # Filter false positives
        filtered_vulnerabilities = self._filter_false_positives(
            self._get_all_vulnerabilities(scan_results)
        )
        
        # Perform risk assessment
        risk_assessments = self._assess_vulnerability_risks(filtered_vulnerabilities)
        
        # Generate remediation plan
        remediation_plan = self._generate_remediation_plan(
            filtered_vulnerabilities, 
            risk_assessments
        )
        
        # Analyze trends if historical data is available
        trends = None
        if historical_data:
            trends = self._analyze_trends(scan_results, historical_data)
        
        # Generate executive summary and recommendations
        executive_summary = self._generate_executive_summary(
            scan_results, risk_assessments, remediation_plan
        )
        recommendations = self._generate_recommendations(
            risk_assessments, remediation_plan
        )
        
        return AnalysisReport(
            report_id=f"analysis_{scan_results.scan_id}",
            scan_results=scan_results,
            risk_assessments=risk_assessments,
            remediation_plan=remediation_plan,
            trends=trends,
            executive_summary=executive_summary,
            recommendations=recommendations
        )
    
    def _get_all_vulnerabilities(self, scan_results: SecurityScanResults) -> List[Vulnerability]:
        """Extract all vulnerabilities from scan results."""
        all_vulnerabilities = []
        for scan_result in scan_results.scan_results:
            all_vulnerabilities.extend(scan_result.vulnerabilities)
        return all_vulnerabilities
    
    def _filter_false_positives(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """Filter out likely false positives."""
        filtered = []
        
        for vuln in vulnerabilities:
            if not self._is_likely_false_positive(vuln):
                filtered.append(vuln)
            else:
                logger.debug(f"Filtered false positive: {vuln.id}")
        
        return filtered
    
    def _is_likely_false_positive(self, vulnerability: Vulnerability) -> bool:
        """Determine if a vulnerability is likely a false positive."""
        # Check against known false positive patterns
        for pattern in self.false_positive_patterns:
            if self._matches_pattern(vulnerability, pattern):
                return True
        
        # Check for test files
        if vulnerability.file_path:
            test_indicators = ['test_', '_test.', '/test/', '/tests/', 'spec.', '_spec.']
            if any(indicator in vulnerability.file_path.lower() for indicator in test_indicators):
                return True
        
        # Check for example/demo code
        if vulnerability.file_path:
            demo_indicators = ['example', 'demo', 'sample', 'tutorial']
            if any(indicator in vulnerability.file_path.lower() for indicator in demo_indicators):
                return True
        
        return False
    
    def _matches_pattern(self, vulnerability: Vulnerability, pattern: Dict) -> bool:
        """Check if vulnerability matches a false positive pattern."""
        # Simple pattern matching - can be enhanced with more sophisticated logic
        if pattern.get('vulnerability_type') and vulnerability.vulnerability_type != pattern['vulnerability_type']:
            return False
        
        if pattern.get('title_contains'):
            if pattern['title_contains'].lower() not in vulnerability.title.lower():
                return False
        
        if pattern.get('file_path_contains') and vulnerability.file_path:
            if pattern['file_path_contains'].lower() not in vulnerability.file_path.lower():
                return False
        
        return True
    
    def _assess_vulnerability_risks(
        self, 
        vulnerabilities: List[Vulnerability]
    ) -> List[VulnerabilityRiskAssessment]:
        """Assess risk for each vulnerability."""
        risk_assessments = []
        
        for vuln in vulnerabilities:
            assessment = self._assess_single_vulnerability_risk(vuln)
            risk_assessments.append(assessment)
        
        return risk_assessments
    
    def _assess_single_vulnerability_risk(
        self, 
        vulnerability: Vulnerability
    ) -> VulnerabilityRiskAssessment:
        """Assess risk for a single vulnerability."""
        # Base scores from severity
        severity_scores = {
            SeverityLevel.CRITICAL: (9.0, 9.0, 8.0),
            SeverityLevel.HIGH: (7.0, 7.0, 6.0),
            SeverityLevel.MEDIUM: (5.0, 5.0, 4.0),
            SeverityLevel.LOW: (3.0, 3.0, 2.0),
            SeverityLevel.INFO: (1.0, 1.0, 1.0)
        }
        
        base_exploitability, base_impact, base_likelihood = severity_scores.get(
            vulnerability.severity, (5.0, 5.0, 5.0)
        )
        
        # Adjust scores based on vulnerability type
        exploitability_score = self._adjust_exploitability_score(
            base_exploitability, vulnerability
        )
        impact_score = self._adjust_impact_score(base_impact, vulnerability)
        likelihood_score = self._adjust_likelihood_score(base_likelihood, vulnerability)
        
        # Calculate overall risk level
        risk_level = self._calculate_risk_level(
            exploitability_score, impact_score, likelihood_score
        )
        
        # Determine remediation priority
        remediation_priority = self._determine_remediation_priority(
            risk_level, vulnerability
        )
        
        # Estimate remediation hours
        estimated_hours = self._estimate_remediation_hours(vulnerability)
        
        return VulnerabilityRiskAssessment(
            vulnerability_id=vulnerability.id,
            risk_level=risk_level,
            exploitability_score=exploitability_score,
            impact_score=impact_score,
            likelihood_score=likelihood_score,
            business_impact=self._assess_business_impact(vulnerability),
            technical_impact=self._assess_technical_impact(vulnerability),
            remediation_priority=remediation_priority,
            estimated_remediation_hours=estimated_hours
        )
    
    def _adjust_exploitability_score(
        self, 
        base_score: float, 
        vulnerability: Vulnerability
    ) -> float:
        """Adjust exploitability score based on vulnerability characteristics."""
        score = base_score
        
        # Increase score for certain vulnerability types
        if vulnerability.vulnerability_type == VulnerabilityType.SECRET_EXPOSURE:
            score += 2.0  # Secrets are easily exploitable
        elif vulnerability.vulnerability_type == VulnerabilityType.DEPENDENCY_VULNERABILITY:
            score += 1.0  # Dependencies often have known exploits
        
        # Adjust based on file location
        if vulnerability.file_path:
            if any(path in vulnerability.file_path for path in ['api/', 'auth/', 'login']):
                score += 1.0  # API and auth vulnerabilities are more exploitable
        
        return min(10.0, max(0.0, score))
    
    def _adjust_impact_score(self, base_score: float, vulnerability: Vulnerability) -> float:
        """Adjust impact score based on vulnerability characteristics."""
        score = base_score
        
        # Increase impact for certain types
        if vulnerability.vulnerability_type == VulnerabilityType.SECRET_EXPOSURE:
            score += 2.0  # Secrets can lead to full system compromise
        elif vulnerability.vulnerability_type == VulnerabilityType.DEPENDENCY_VULNERABILITY:
            score += 1.0  # Can affect entire application
        
        return min(10.0, max(0.0, score))
    
    def _adjust_likelihood_score(
        self, 
        base_score: float, 
        vulnerability: Vulnerability
    ) -> float:
        """Adjust likelihood score based on vulnerability characteristics."""
        score = base_score
        
        # Increase likelihood for public-facing components
        if vulnerability.file_path:
            if any(path in vulnerability.file_path for path in ['api/', 'web/', 'public/']):
                score += 1.0
        
        return min(10.0, max(0.0, score))
    
    def _calculate_risk_level(
        self, 
        exploitability: float, 
        impact: float, 
        likelihood: float
    ) -> RiskLevel:
        """Calculate overall risk level from component scores."""
        # Weighted average with emphasis on impact and exploitability
        risk_score = (exploitability * 0.4 + impact * 0.4 + likelihood * 0.2)
        
        if risk_score >= 8.0:
            return RiskLevel.CRITICAL
        elif risk_score >= 6.0:
            return RiskLevel.HIGH
        elif risk_score >= 4.0:
            return RiskLevel.MEDIUM
        elif risk_score >= 2.0:
            return RiskLevel.LOW
        else:
            return RiskLevel.NEGLIGIBLE
    
    def _determine_remediation_priority(
        self, 
        risk_level: RiskLevel, 
        vulnerability: Vulnerability
    ) -> RemediationPriority:
        """Determine remediation priority based on risk level and other factors."""
        # Base priority from risk level
        risk_priority_map = {
            RiskLevel.CRITICAL: RemediationPriority.IMMEDIATE,
            RiskLevel.HIGH: RemediationPriority.URGENT,
            RiskLevel.MEDIUM: RemediationPriority.HIGH,
            RiskLevel.LOW: RemediationPriority.MEDIUM,
            RiskLevel.NEGLIGIBLE: RemediationPriority.LOW
        }
        
        base_priority = risk_priority_map[risk_level]
        
        # Elevate priority for certain vulnerability types
        if vulnerability.vulnerability_type == VulnerabilityType.SECRET_EXPOSURE:
            if base_priority not in [RemediationPriority.IMMEDIATE]:
                return RemediationPriority.IMMEDIATE
        
        return base_priority
    
    def _estimate_remediation_hours(self, vulnerability: Vulnerability) -> int:
        """Estimate hours needed to remediate vulnerability."""
        base_hours = {
            VulnerabilityType.SECRET_EXPOSURE: 2,  # Quick fix - move to env vars
            VulnerabilityType.CODE_VULNERABILITY: 4,  # Code changes and testing
            VulnerabilityType.DEPENDENCY_VULNERABILITY: 3,  # Update and test
            VulnerabilityType.CONTAINER_VULNERABILITY: 6,  # Container rebuild and test
            VulnerabilityType.CONFIGURATION_ISSUE: 2  # Config changes
        }
        
        return base_hours.get(vulnerability.vulnerability_type, 4)
    
    def _assess_business_impact(self, vulnerability: Vulnerability) -> str:
        """Assess business impact of vulnerability."""
        impact_map = {
            VulnerabilityType.SECRET_EXPOSURE: "Potential data breach, compliance violations, reputation damage",
            VulnerabilityType.CODE_VULNERABILITY: "Application compromise, data integrity issues",
            VulnerabilityType.DEPENDENCY_VULNERABILITY: "Third-party exploit, supply chain attack",
            VulnerabilityType.CONTAINER_VULNERABILITY: "Container escape, infrastructure compromise",
            VulnerabilityType.CONFIGURATION_ISSUE: "Security misconfiguration, privilege escalation"
        }
        
        return impact_map.get(
            vulnerability.vulnerability_type, 
            "Potential security compromise"
        )
    
    def _assess_technical_impact(self, vulnerability: Vulnerability) -> str:
        """Assess technical impact of vulnerability."""
        impact_map = {
            VulnerabilityType.SECRET_EXPOSURE: "Unauthorized access to systems and data",
            VulnerabilityType.CODE_VULNERABILITY: "Code execution, memory corruption, logic bypass",
            VulnerabilityType.DEPENDENCY_VULNERABILITY: "Known exploits, remote code execution",
            VulnerabilityType.CONTAINER_VULNERABILITY: "Container breakout, host system access",
            VulnerabilityType.CONFIGURATION_ISSUE: "Privilege escalation, access control bypass"
        }
        
        return impact_map.get(
            vulnerability.vulnerability_type, 
            "System security compromise"
        )
    
    def _generate_remediation_plan(
        self, 
        vulnerabilities: List[Vulnerability],
        risk_assessments: List[VulnerabilityRiskAssessment]
    ) -> RemediationPlan:
        """Generate comprehensive remediation plan."""
        # Group vulnerabilities by type and priority
        vulnerability_groups = self._group_vulnerabilities_for_remediation(
            vulnerabilities, risk_assessments
        )
        
        actions = []
        total_hours = 0
        
        # Generate actions for each group
        for group_type, group_vulns in vulnerability_groups.items():
            action = self._create_remediation_action(group_type, group_vulns)
            actions.append(action)
            total_hours += action.estimated_hours
        
        # Sort actions by priority
        priority_order = [
            RemediationPriority.IMMEDIATE,
            RemediationPriority.URGENT,
            RemediationPriority.HIGH,
            RemediationPriority.MEDIUM,
            RemediationPriority.LOW
        ]
        actions.sort(key=lambda x: priority_order.index(x.priority))
        
        # Calculate timeline
        timeline_weeks = max(1, total_hours // 40)  # Assuming 40 hours per week
        
        # Generate success criteria
        success_criteria = self._generate_success_criteria(vulnerabilities)
        
        return RemediationPlan(
            plan_id=f"remediation_plan_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            created_at=datetime.now(),
            total_vulnerabilities=len(vulnerabilities),
            critical_count=len([v for v in vulnerabilities if v.severity == SeverityLevel.CRITICAL]),
            high_count=len([v for v in vulnerabilities if v.severity == SeverityLevel.HIGH]),
            estimated_total_hours=total_hours,
            actions=actions,
            timeline_weeks=timeline_weeks,
            success_criteria=success_criteria
        )
    
    def _group_vulnerabilities_for_remediation(
        self, 
        vulnerabilities: List[Vulnerability],
        risk_assessments: List[VulnerabilityRiskAssessment]
    ) -> Dict[str, List[Tuple[Vulnerability, VulnerabilityRiskAssessment]]]:
        """Group vulnerabilities for efficient remediation."""
        groups = defaultdict(list)
        
        # Create assessment lookup
        assessment_map = {ra.vulnerability_id: ra for ra in risk_assessments}
        
        for vuln in vulnerabilities:
            assessment = assessment_map.get(vuln.id)
            if not assessment:
                continue
            
            # Group by vulnerability type and priority
            group_key = f"{vuln.vulnerability_type.value}_{assessment.remediation_priority.value}"
            groups[group_key].append((vuln, assessment))
        
        return dict(groups)
    
    def _create_remediation_action(
        self, 
        group_type: str, 
        group_vulns: List[Tuple[Vulnerability, VulnerabilityRiskAssessment]]
    ) -> RemediationAction:
        """Create remediation action for a group of vulnerabilities."""
        vuln_type, priority = group_type.split('_', 1)
        priority_enum = RemediationPriority(priority)
        
        # Get template for this vulnerability type
        template = self.remediation_templates.get(vuln_type, {})
        
        affected_vuln_ids = [vuln.id for vuln, _ in group_vulns]
        total_hours = sum(assessment.estimated_remediation_hours or 4 for _, assessment in group_vulns)
        
        return RemediationAction(
            action_id=f"action_{group_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
            title=template.get('title', f"Remediate {vuln_type} vulnerabilities"),
            description=template.get('description', f"Address {len(group_vulns)} {vuln_type} vulnerabilities"),
            priority=priority_enum,
            estimated_hours=total_hours,
            affected_vulnerabilities=affected_vuln_ids,
            prerequisites=template.get('prerequisites', []),
            verification_steps=template.get('verification_steps', []),
            resources_needed=template.get('resources_needed', [])
        )
    
    def _generate_success_criteria(self, vulnerabilities: List[Vulnerability]) -> List[str]:
        """Generate success criteria for remediation plan."""
        criteria = [
            "All critical vulnerabilities resolved",
            "All high-severity vulnerabilities resolved or accepted as risk",
            "Security scan passes with zero critical findings",
            "Code review completed for all security fixes",
            "Updated security documentation"
        ]
        
        # Add specific criteria based on vulnerability types
        vuln_types = set(v.vulnerability_type for v in vulnerabilities)
        
        if VulnerabilityType.SECRET_EXPOSURE in vuln_types:
            criteria.append("All hardcoded secrets moved to secure configuration")
        
        if VulnerabilityType.DEPENDENCY_VULNERABILITY in vuln_types:
            criteria.append("All vulnerable dependencies updated to secure versions")
        
        if VulnerabilityType.CONTAINER_VULNERABILITY in vuln_types:
            criteria.append("Container images rebuilt and rescanned")
        
        return criteria
    
    def _analyze_trends(
        self, 
        current_scan: SecurityScanResults,
        historical_scans: List[SecurityScanResults]
    ) -> List[VulnerabilityTrend]:
        """Analyze vulnerability trends over time."""
        # This is a simplified implementation - can be enhanced with more sophisticated analysis
        trends = []
        
        if len(historical_scans) >= 1:
            previous_scan = historical_scans[-1]
            
            # Calculate changes
            current_counts = current_scan.severity_counts
            previous_counts = previous_scan.severity_counts
            
            new_vulns = current_scan.total_vulnerabilities - previous_scan.total_vulnerabilities
            
            # Determine trend direction
            critical_change = current_counts[SeverityLevel.CRITICAL] - previous_counts[SeverityLevel.CRITICAL]
            high_change = current_counts[SeverityLevel.HIGH] - previous_counts[SeverityLevel.HIGH]
            
            if critical_change > 0 or high_change > 2:
                trend_direction = "degrading"
            elif critical_change < 0 and high_change <= 0:
                trend_direction = "improving"
            else:
                trend_direction = "stable"
            
            trend = VulnerabilityTrend(
                period="current_vs_previous",
                vulnerability_counts=current_counts,
                new_vulnerabilities=max(0, new_vulns),
                resolved_vulnerabilities=max(0, -new_vulns),
                trend_direction=trend_direction,
                risk_score_change=critical_change * 2 + high_change
            )
            trends.append(trend)
        
        return trends
    
    def _generate_executive_summary(
        self, 
        scan_results: SecurityScanResults,
        risk_assessments: List[VulnerabilityRiskAssessment],
        remediation_plan: RemediationPlan
    ) -> str:
        """Generate executive summary of security analysis."""
        critical_count = scan_results.severity_counts[SeverityLevel.CRITICAL]
        high_count = scan_results.severity_counts[SeverityLevel.HIGH]
        
        immediate_actions = len(remediation_plan.get_immediate_actions())
        
        summary = f"""
Security Analysis Executive Summary

Total Vulnerabilities Found: {scan_results.total_vulnerabilities}
- Critical: {critical_count}
- High: {high_count}
- Medium: {scan_results.severity_counts[SeverityLevel.MEDIUM]}
- Low: {scan_results.severity_counts[SeverityLevel.LOW]}

Risk Assessment:
- {len([ra for ra in risk_assessments if ra.risk_level == RiskLevel.CRITICAL])} vulnerabilities assessed as critical risk
- {len([ra for ra in risk_assessments if ra.risk_level == RiskLevel.HIGH])} vulnerabilities assessed as high risk

Remediation Plan:
- {immediate_actions} actions require immediate attention
- Estimated {remediation_plan.estimated_total_hours} hours of work
- {remediation_plan.timeline_weeks} week timeline for completion

Compliance Status: {'PASS' if scan_results.compliance_status.get('overall_compliance', False) else 'FAIL'}
"""
        
        return summary.strip()
    
    def _generate_recommendations(
        self, 
        risk_assessments: List[VulnerabilityRiskAssessment],
        remediation_plan: RemediationPlan
    ) -> List[str]:
        """Generate strategic recommendations."""
        recommendations = []
        
        # Immediate action recommendations
        immediate_actions = remediation_plan.get_immediate_actions()
        if immediate_actions:
            recommendations.append(
                f"Immediately address {len(immediate_actions)} critical security issues"
            )
        
        # Secret management recommendations
        secret_vulns = [
            ra for ra in risk_assessments 
            if 'SECRET' in ra.vulnerability_id
        ]
        if secret_vulns:
            recommendations.append(
                "Implement comprehensive secrets management solution"
            )
        
        # Dependency management recommendations
        dep_vulns = [
            ra for ra in risk_assessments 
            if 'SAFETY' in ra.vulnerability_id
        ]
        if dep_vulns:
            recommendations.append(
                "Establish automated dependency vulnerability monitoring"
            )
        
        # General security recommendations
        recommendations.extend([
            "Integrate security scanning into CI/CD pipeline",
            "Establish regular security review processes",
            "Implement security training for development team",
            "Consider implementing security champions program"
        ])
        
        return recommendations
    
    def _load_false_positive_patterns(self) -> List[Dict]:
        """Load patterns for identifying false positives."""
        # This could be loaded from a configuration file
        return [
            {
                'vulnerability_type': VulnerabilityType.SECRET_EXPOSURE,
                'title_contains': 'example',
                'description': 'Example or placeholder secrets'
            },
            {
                'vulnerability_type': VulnerabilityType.CODE_VULNERABILITY,
                'file_path_contains': 'test',
                'description': 'Test code vulnerabilities'
            }
        ]
    
    def _load_remediation_templates(self) -> Dict[str, Dict]:
        """Load remediation action templates."""
        return {
            'SECRET_EXPOSURE': {
                'title': 'Secure hardcoded secrets',
                'description': 'Move hardcoded secrets to environment variables or secure secret management',
                'prerequisites': ['Access to deployment environment', 'Secret management system'],
                'verification_steps': [
                    'Verify no hardcoded secrets remain in code',
                    'Test application with environment variables',
                    'Confirm secrets are properly secured'
                ],
                'resources_needed': ['Developer time', 'DevOps support']
            },
            'DEPENDENCY_VULNERABILITY': {
                'title': 'Update vulnerable dependencies',
                'description': 'Update dependencies to secure versions and test compatibility',
                'prerequisites': ['Dependency management tools', 'Test environment'],
                'verification_steps': [
                    'Update dependencies to secure versions',
                    'Run full test suite',
                    'Verify application functionality'
                ],
                'resources_needed': ['Developer time', 'QA testing']
            },
            'CODE_VULNERABILITY': {
                'title': 'Fix code security issues',
                'description': 'Address security vulnerabilities in application code',
                'prerequisites': ['Code review process', 'Security expertise'],
                'verification_steps': [
                    'Implement security fixes',
                    'Conduct security code review',
                    'Run security tests'
                ],
                'resources_needed': ['Developer time', 'Security review']
            },
            'CONTAINER_VULNERABILITY': {
                'title': 'Secure container configuration',
                'description': 'Address container security misconfigurations',
                'prerequisites': ['Container expertise', 'Build pipeline access'],
                'verification_steps': [
                    'Update container configurations',
                    'Rebuild and test containers',
                    'Verify security improvements'
                ],
                'resources_needed': ['DevOps time', 'Container expertise']
            }
        }